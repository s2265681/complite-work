# 输入一个URL做了什么？

- 进程与线程

  1、**什么进程**：CPU资源**分配**的最小单位---进行中的程序，独立运行且拥有自己的资源空间的任务程序

  进程包括运行中的程序和程序所使用到的内存和系统资源

  CPU运行一个进程时其他进程处于非运行状态，CPU使用时间片轮转调度算法来实现同时运行多个进程

  2、**什么是线程**：CPU**调度**的最小单位，是建立在一次进程的基础上的一次程序运行单位，程序中的一个执行流，一个进程可以有多个线程。

  一个进程中，有一个执行流成为单线程，即执行时，必须前一个处理好，后一个才执行

  一个 `进程` 中有多个执行流称作 `多线程`，允许单个程序创建多个并行的线程来完成个字的任务。

- 进程和线程的区别

   进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。

   一个进程有一个或多个线程组成，线程可理解为一个进程中代码的不同执行路线

   进程之间相互独立，线程共享程序的内存空间

- 多进程和多线程

   【多进程：】多进程是在同一时间内，计算机系统允许两个或两个以上的进程运行，进程间不相互干扰

​    【多线程：】程序中包含多个执行流，一个程序可以同时运行不同的线程来执行不同的任务，允许单个程序创建多个并行执行线程来完成各自任务

- JS为什么是单线程

   根用途有关，作为浏览器的脚本语言，主要用于用户互动以及操作dom，决定了他只能单线程，否在会带来很复杂的同步问题。

为了更好的利用多核CPU的计算能力，HTML5提出了Web Worker标准，郧西javascript创建多个线程，但是子线程完全受注线程控制，而且不得操作DOM，没有改变Javascript单线程的本质

- 浏览器相关

- 浏览器是多进程的：

  1、 包含Browser进程（主控，协调）与用户交互，创建销毁其他进程，网络资源的下载等

  2、第三方插件进程，使用使创建

  3、GPU进程，用于3D/动画绘图，绘制到用户界面上

  4、renderer渲染进程（重）：浏览器内核，页面渲染、脚本执行、事件处理

  渲染进程是多线程的，页面的渲染，JS的执行，事件的循环，都是在渲染进程内执行

- 渲染进程Renderer的主要线程

  **GUI渲染线程**：负责渲染浏览器界面，解析HTML，CSS构建DOM树和RenderObject树，          布局和绘制等。

  - 当我们修改一些元素的颜色背景色，页面会重绘

  - 当我们修改一些元素的尺寸会引发页面的回流，重新计算元素的位置大小

  - GUI线程和JS引擎线程是互斥的

  - 当JS引擎执行时，GUI线程会被挂起

  - GUI更新会被保存在一个队列中等到JS引擎空闲时立即执行

  **JS引擎线程**

  - JS引擎线程就是JS内核，负责处理Javascript脚本（如V8引擎）运行代码
  - 一直等待任务队列中的任务到来，然后加以处理
  - GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程

  **事件触发线程**

  - 属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)
  - 当js执行碰到事件绑定和一些异步操作,会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
  - 因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理

  **定时触发器线程**

  - `setInterval` 与 `setTimeout` 所在线程
  - 浏览器定时计数器并不是由JavaScript引擎计数的 (因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)

  **异步http请求线程**

  - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
  - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行
  - 简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应 (准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行

> 渲染过程

​    ![pic](https://mmbiz.qpic.cn/mmbiz_png/NPULUrHfJojbc0eJ8DaYRXezib4E2xhFXBiaCSIBAWy04TSUl5YV6hbXvACc9cwfeqXHXNruib9bqcjCcIibAV1VxA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 )

解析HTML构建DOM树

首先，发起请求拿到页面 HTML 内容，这个内容它是0/1这样的原始 `字节流`

接着，浏览器拿到这些 HTML 的原始字节，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 `字符`

然后通过词法解析：我们把字符流解析成了 词 (Token)

语法解析：开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 `DOM` 树

### 解析CSS构建CSSOM树

`CSS` 字节转换成字符，接着词法解析与法解析，最后构成 `CSS对象模型(CSSOM)` 的树结构

节点样式是可以继承的

所以在构建的过程中浏览器得递归 `DOM` 树来确定元素到底是什么样式，为了 `CSSOM` 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 `DOM` 已经构建完了，也得等 `CSSOM`，然后才能进入下一个阶段

所以 `CSS` 的加载速度与构建 `CSSOM` 的速度会影响首屏渲染速度，这就是我们常说的 `CSS` 资源的加载会阻塞渲染

怎么优化？DOM树要小，CSS尽量用 `id` 和 `class` 少直接用标签😄

### 解析JavaScript脚本

**「JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建」**

若不阻塞DOM树的构建，若 JS 删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的

若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到HTML 底部进行加载，或是对 JS 文件执行 `async` 或 `defer` 加载

### 构建渲染树/呈现树(Render Tree)

`CSSOM 树`和 `DOM 树` 合并成渲染树，`渲染树` 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上

- 浏览器首先会从DOM树的根节点开始遍历每个可见节点

- - 例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略
  - 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如一个 `span` 标签有 `display: none` 属性，也会被忽略

- 对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们

- 输出可见节点，连同其内容和计算的样式

### 布局(Layout)

计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 视口[2] 内的确切位置和大小，这就是 `布局` ( Layout ) 阶段，也称为 `自动重排` 或 `回流` ( Reflow )

### 绘制(Painting)

它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 `绘制` 或 `栅格化`

#### 重绘(Repaint)

元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 `重绘` ( Repaint )

#### 回流 (Reflow)

上面我们已经说过了 `回流` ，当然也叫 `重排` ，要知道，`回流` 一定伴随着 `重绘` ，`重绘` 却可以单独出现，对比来看，显然回流的成本开销要高于重绘，而且一个节点的回流往往还会导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免 `回流`

**什么会引起回流？**

- 页面渲染初始化
- DOM结构改变，比如删除了某个节点
- render树变化，比如减少了padding
- 窗口 `resize`

#### 如何减少和避免回流重绘

回流开销太大了，那么我们肯定是要优化的

- 减少逐项更改样式，最好一次性更改 `style`，

- 避免循环操作DOM，让DOM离线后再修改

  - 创建一个documentFragment，在上面操作dom后，再添加到window.document上
  - 先把DOM节点display:none, 修改后再重新显示出来
  - 克隆一个DOM节点，修改之后与在线的节点相替换

- 将复杂的元素绝对定位或固定定位，是他们脱离文档流，否则回流代价很高

- 改变字体大小也会引发回流，应避免

- table布局，微小改动也会重新布局，少用为好

  https://csstriggers.com/

  

### 合成(Composite)

浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上



#### 浏览器渲染方式

- 绘图上下文

  - 2D图形上下文
  - 3D图形上下文

- 网页三种渲染

  - 软件渲染
  - 使用软件绘图的合成化渲染
  - 硬件加速的合成化渲染

  

#### 软件渲染技术

- 1、绘制该层中所以块的背景和边框
- 2、绘制浮动内容
- 3、前景，内容部分、轮廓、字体颜色、大小等



#### 硬件加速技术

硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU的作用主要是用来绘制3D图形并且性能很 nice )



## 页面渲染优化

- HTML文档结构层次尽量少，最好不超过六层

- JS脚本尽量后放

- 样式结构层次尽量简单

- 在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流

- 减少JS代码修改样式，使用class或样式操作动画

- 不使用table布局

- CSS动画中尽量只使用transform和opacity，不会发生重排和重绘

  

## 最后

发起一个请求，拿到页面后，下载玩的网页交给浏览器内核（渲染进程）之后

- 首先，根据顶部定义的DTD类型进行对应的解析方式
- 渲染进程内不是多线程的，网页的解析将会交给内部的GUI渲染线程处理
- 渲染线程中的HTML解析器，将HTML网页和资源从字节流解释转换成字符流
- 通过词法分析器将字符流解释成词
- 经过语法分析器根基词构建成节点，最后通过这些节点组件一个DOM树
- 这个过程中，如果遇到DOM节点是JS代码，就会调用JS引擎，对JS进行解释执行，此时由JS引擎和GUI渲染线程互斥，GUI渲染线程就会被挂起，渲染过程停止，如果JS代码的运行中对DOM进行了修改，那么DOM的构建需要从新开始
- 如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建
- 如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 `JS引擎` 执行后才继续构建DOM
- 对于CSS，CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树
- 然后合并CSS规则树和DOM树，生成 Render渲染树，也叫呈现树
- 最后对 Render树进行布局和绘制，并将结果通过IO线程传递给浏览器控制进程进行显示