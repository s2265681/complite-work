<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    时间复杂度
    CPU计算时间 
    const a = [1,2,3,4,5]
    ---------  0Xa0  0Xa1 
    a.sort()
    a.length
    a[1]  // 消耗1
    a[2]  // 消耗1
    javascript 内存池 ->  操作系统的内存池  
    数组赋值是1的时间，给变量赋值1的时间，字符串的赋值和数组的赋值是一样的 
    let str = 'hello world'  str[1] e

    // 对象的创造
    const obj = {}

    字符串的加减乘除

    Math.pow(10,10)   
    Math.sqrt(100)


    // 显卡 CPU上 矩阵
    1_2 * 2_3
    3_4 * 4_5

    // 前端性能意义
    前端相比服务端，性能要求更高
    解决流畅问题
    老旧机型  适配  如果一个算法优化失误  在其他页面可能造成雪崩

    预习 线性时间算法
    > 暴力方法 遍历 

    function find(arr,value){
        for(let i=0; i< arr.length;i++){
            if(arr[i] === value){
                return value
            }
        }
        return null
    }

    这个算法怎么衡量
    // 怎么生成100万条数据，随机打乱数据

    // 大数定理 随机大数 达到一定程度 趋于稳定

    
</body>
<script>
    function renderData(num){
        let arr = []
        for(let i=0;i<num;i++){
          arr.push(i)
        }
       return shufffle(arr)
    }

    function shufffle_sipmle(arr){
        return arr.sort((a,b)=>Math.random() - 0.5)
    }

    function shufffle(arr){
        for(let i=0;i<arr.length-1;i++){
           const j = i + Math.floor(Math.random() * (arr.length - i ));
           [ arr[i] ,  arr[j] ] = [ arr[j] ,  arr[i] ];
        }
        return arr
    }
    
    console.log(renderData(10))
</script>
</html>